<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <!-- Responsive scaling and safe‐area for notches -->
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Redact Tool</title>

  <!-- PDF.js for PDF rendering -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.6.172/pdf.min.js"></script>
  <!-- jsPDF for exporting PDF -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <style>
    /* ===== Global Reset ===== */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    html, body {
      width: 100%;
      height: 100%;
      background: #0d0d0f;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      overscroll-behavior: none; /* prevent pull‐to‐refresh */
    }

    /* ===== Glassmorphic Container ===== */
    .glass-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      background: rgba(255, 255, 255, 0.03);
      backdrop-filter: blur(40px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* ===== Controls Row (compact) ===== */
    .controls {
      padding: 6px 8px;
      display: flex;
      gap: 6px;
      justify-content: center;
      background: rgba(255, 255, 255, 0.04);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      flex-wrap: wrap;
    }
    .controls button {
      padding: 4px 8px;
      border: none;
      border-radius: 6px;
      background: linear-gradient(145deg, rgba(255,255,255,0.1), rgba(255,255,255,0));
      color: #fff;
      cursor: pointer;
      font-size: 0.85rem;
      transition: background 0.2s ease, transform 0.2s ease;
    }
    .controls button:disabled {
      opacity: 0.3;
      cursor: default;
    }
    .controls button:hover:not(:disabled) {
      background: linear-gradient(145deg, rgba(255,255,255,0.2), rgba(255,255,255,0.05));
      transform: translateY(-1px);
    }

    /* ===== Main Canvas Area ===== */
    .canvas-area {
      flex: 1;
      position: relative;
      background: #1a1a1c;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      touch-action: none; /* prevent default gestures */
    }
    video {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 4px;
      z-index: 1;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      /* canvas internal size is set via width/height attributes */
      border-radius: 4px;
      z-index: 2;
      pointer-events: auto;
      touch-action: none;
    }

    /* ===== Overlay Controls (Camera) ===== */
    .overlay-controls {
      position: absolute;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 6px;
      z-index: 3;
    }
    .overlay-controls button {
      padding: 4px 8px;
      border: none;
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.12);
      color: #fff;
      cursor: pointer;
      font-size: 0.75rem;
      transition: background 0.2s ease, transform 0.2s ease;
    }
    .overlay-controls button:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: translateY(-1px);
    }

    /* ===== Hidden File Input ===== */
    #fileInput {
      display: none;
    }
  </style>
</head>
<body>
  <div class="glass-container">
    <div class="controls">
      <button id="cameraBtn">Camera</button>
      <button id="uploadBtn">Upload</button>
      <button id="penToolBtn" disabled>Pen</button>
      <button id="penPlusBtn" disabled>Pen +</button>
      <button id="penMinusBtn" disabled>Pen -</button>
      <button id="undoBtn" disabled>Undo</button>
      <button id="resetBtn" disabled>Reset</button>
      <button id="saveBtn" disabled>Save</button>
      <input type="file" id="fileInput" accept="image/*,application/pdf" capture="environment" />
    </div>

    <div class="canvas-area" id="canvasArea">
      <video id="video" autoplay muted playsinline style="display:none;"></video>
      <canvas id="canvas"></canvas>
      <div class="overlay-controls" id="overlayControls" style="display:none;">
        <button id="captureBtn">Capture</button>
        <button id="stopCameraBtn">Close</button>
      </div>
    </div>
  </div>

  <script>
    // ===== Global Variables =====
    const cameraBtn     = document.getElementById('cameraBtn');
    const uploadBtn     = document.getElementById('uploadBtn');
    const penToolBtn    = document.getElementById('penToolBtn');
    const penPlusBtn    = document.getElementById('penPlusBtn');
    const penMinusBtn   = document.getElementById('penMinusBtn');
    const undoBtn       = document.getElementById('undoBtn');
    const resetBtn      = document.getElementById('resetBtn');
    const saveBtn       = document.getElementById('saveBtn');
    const fileInput     = document.getElementById('fileInput');
    const video         = document.getElementById('video');
    const canvas        = document.getElementById('canvas');
    let ctx             = canvas.getContext('2d');
    const overlayControls = document.getElementById('overlayControls');
    const captureBtn      = document.getElementById('captureBtn');
    const stopCameraBtn   = document.getElementById('stopCameraBtn');

    let stream = null;
    let currentMode = null; // "camera" | "image" | "pdf"
    let isPenActive = false;
    let isDrawing    = false;
    let pdfDoc       = null;
    let pdfPageNum   = 1;
    let loadedImage  = new Image();

    // Pen strokes and brush size
    let penStrokes    = [];
    let currentStroke = [];
    let brushSize     = 20; // default

    // ===== Utility: Resize Canvas to Match Its CSS Display Size =====
    function resizeCanvas() {
      // We do NOT change canvas.width/height attributes here
      // because those represent its internal drawing resolution.
      // Instead, we only keep track of CSS size for coordinate scaling.
      // Canvas actual resolution is set on capture or when loading PDF/image.
      // No action needed here.
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // ===== Camera Handlers =====
    cameraBtn.addEventListener('click', async () => {
      if (stream) return;
      try {
        // Request high‐res rear camera
        stream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: { exact: 'environment' },
            width:  { ideal: 1920 },
            height: { ideal: 1080 }
          }
        });
      } catch {
        try {
          stream = await navigator.mediaDevices.getUserMedia({
            video: {
              facingMode: 'environment',
              width:  { ideal: 1920 },
              height: { ideal: 1080 }
            }
          });
        } catch {
          stream = null;
        }
      }
      if (stream) {
        video.srcObject = stream;
        video.style.display = 'block';
        overlayControls.style.display = 'flex';
        currentMode = 'camera';
        disableActionButtons();
      } else {
        alert(
          'Unable to access the high‐res rear camera.\n' +
          '• Ensure you’re on HTTPS (not file:// or HTTP).\n' +
          '• Close any overlays blocking the permission prompt.'
        );
      }
    });

    captureBtn.addEventListener('click', () => {
      if (!stream) return;
      // Use camera’s native resolution
      const vw = video.videoWidth;
      const vh = video.videoHeight;
      // Resize canvas’s internal drawing buffer to full camera resolution
      canvas.width  = vw;
      canvas.height = vh;
      // Draw the full‐res frame
      ctx.drawImage(video, 0, 0, vw, vh);
      // Stop & hide video
      stopCamera();
      video.style.display = 'none';
      video.srcObject     = null;
      // Now loadedImage contains that high‐res data
      currentMode = 'image';
      loadedImage.src = canvas.toDataURL('image/png');
      loadedImage.onload = () => {
        // After loaded, draw scaled down to fit viewport
        drawImageScaled(loadedImage);
        enableActionButtons();
      };
    });

    stopCameraBtn.addEventListener('click', stopCamera);
    function stopCamera() {
      if (stream) {
        stream.getTracks().forEach((t) => t.stop());
        stream = null;
        video.style.display = 'none';
        overlayControls.style.display = 'none';
      }
    }

    // ===== Upload Handlers =====
    uploadBtn.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const fileType = file.type;
      clearCanvas();
      if (fileType === 'application/pdf') {
        currentMode = 'pdf';
        const arrayBuffer = await file.arrayBuffer();
        await loadAndRenderPdf(arrayBuffer);
      } else if (fileType.startsWith('image/')) {
        currentMode = 'image';
        const url = URL.createObjectURL(file);
        loadedImage = new Image();
        loadedImage.src = url;
        loadedImage.onload = () => {
          // Use the image’s natural size for drawing buffer
          canvas.width  = loadedImage.naturalWidth;
          canvas.height = loadedImage.naturalHeight;
          ctx.drawImage(loadedImage, 0, 0);
          // Then scale to fit viewport
          drawImageScaled(loadedImage);
          enableActionButtons();
        };
      } else {
        alert('Unsupported file type. Please upload a PDF or image.');
      }
      fileInput.value = '';
    });

    // ===== PDF Rendering with PDF.js =====
    async function loadAndRenderPdf(data) {
      try {
        pdfDoc = await pdfjsLib.getDocument({ data }).promise;
        pdfPageNum = 1;
        renderPdfPage(pdfPageNum);
      } catch (err) {
        console.error('PDF load error:', err);
        alert('Failed to load PDF.');
      }
    }
    function renderPdfPage(num) {
      pdfDoc.getPage(num).then((page) => {
        // Render at natural page size, then scale
        const viewportOrig = page.getViewport({ scale: 1 });
        const pageWidth  = viewportOrig.width;
        const pageHeight = viewportOrig.height;
        // Set canvas buffer to natural PDF page size
        canvas.width  = pageWidth;
        canvas.height = pageHeight;
        // Render onto canvas buffer
        const renderContext = {
          canvasContext: ctx,
          viewport: viewportOrig
        };
        page.render(renderContext).promise.then(() => {
          // Once rendered, scale down to fit viewport
          drawPdfScaled(pageWidth, pageHeight);
          enableActionButtons();
        }).catch((err) => {
          console.error('PDF render promise error:', err);
        });
      }).catch((err) => {
        console.error('PDF render error:', err);
      });
    }

    // ===== Scaling Helpers =====
    function drawImageScaled(img) {
      // Keep buffer at img.naturalWidth/naturalHeight; 
      // draw scaled to fill CSS viewport.
      const rect = canvas.parentElement.getBoundingClientRect();
      // Temporarily clear CSS size (not needed, CSS 100% covers)
      // Draw buffer->CSS by using drawImage with dest as CSS dims
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height, 0, 0, rect.width, rect.height);
      // Now, set CSS size explicitly and keep buffer as is
      canvas.style.width  = rect.width + 'px';
      canvas.style.height = rect.height + 'px';
    }
    function drawPdfScaled(pageWidth, pageHeight) {
      const rect = canvas.parentElement.getBoundingClientRect();
      ctx.clearRect(0, 0, pageWidth, pageHeight);
      ctx.drawImage(canvas, 0, 0, pageWidth, pageHeight, 0, 0, rect.width, rect.height);
      canvas.style.width  = rect.width + 'px';
      canvas.style.height = rect.height + 'px';
    }

    // ===== Drawing & Pen Redaction (Pointer Events) =====
    function clearCanvas() {
      // Clear buffer
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // Reset CSS size to fill parent
      const rect = canvas.parentElement.getBoundingClientRect();
      canvas.style.width  = rect.width + 'px';
      canvas.style.height = rect.height + 'px';
      penStrokes    = [];
      currentStroke = [];
      disableUndoReset();
    }

    function redrawBase() {
      if (currentMode === 'image' && loadedImage.src) {
        // Buffer & CSS already set by drawImageScaled
        // Just redraw the buffer->CSS
        drawImageScaled(loadedImage);
      } else if (currentMode === 'pdf' && pdfDoc) {
        // Re-render current PDF page
        renderPdfPage(pdfPageNum);
      }
    }

    function redrawPenStrokes() {
      // Draw each stroke onto the buffer, then scale to CSS
      const rect = canvas.parentElement.getBoundingClientRect();
      // Clear CSS display
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // Re-draw base buffer into itself to preserve original
      // (Assumes buffer already holds the base image/PDF)
      // Then overlay strokes:
      penStrokes.forEach((stroke) => {
        ctx.save();
        ctx.globalCompositeOperation = 'source-over';
        ctx.strokeStyle = '#000';
        ctx.lineWidth   = brushSize;
        ctx.lineCap     = 'round';
        ctx.lineJoin    = 'round';
        ctx.beginPath();
        stroke.forEach((pt, idx) => {
          if (idx === 0) ctx.moveTo(pt.x, pt.y);
          else ctx.lineTo(pt.x, pt.y);
        });
        ctx.stroke();
        ctx.restore();
      });
      // Finally, scale buffer->CSS
      ctx.drawImage(canvas, 0, 0, canvas.width, canvas.height, 0, 0, rect.width, rect.height);
      canvas.style.width  = rect.width + 'px';
      canvas.style.height = rect.height + 'px';
      updateUndoResetState();
    }

    // Pointer event handlers (with coordinate scaling)
    canvas.addEventListener('pointerdown', (e) => {
      if (!['image','pdf'].includes(currentMode) || !isPenActive) return;
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width  / rect.width;
      const scaleY = canvas.height / rect.height;
      const x = (e.clientX - rect.left) * scaleX;
      const y = (e.clientY - rect.top)  * scaleY;
      isDrawing     = true;
      currentStroke = [{ x, y }];
      e.preventDefault();
    }, { passive: false });

    canvas.addEventListener('pointermove', (e) => {
      if (!isDrawing || !isPenActive) return;
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width  / rect.width;
      const scaleY = canvas.height / rect.height;
      const x = (e.clientX - rect.left) * scaleX;
      const y = (e.clientY - rect.top)  * scaleY;
      currentStroke.push({ x, y });

      // Draw onto buffer
      ctx.save();
      ctx.globalCompositeOperation = 'source-over';
      ctx.strokeStyle = '#000';
      ctx.lineWidth   = brushSize;
      ctx.lineCap     = 'round';
      ctx.lineJoin    = 'round';
      ctx.beginPath();
      const lastIdx = currentStroke.length - 1;
      if (lastIdx > 0) {
        const prevPt = currentStroke[lastIdx - 1];
        ctx.moveTo(prevPt.x, prevPt.y);
        ctx.lineTo(currentStroke[lastIdx].x, currentStroke[lastIdx].y);
        ctx.stroke();
      }
      ctx.restore();

      e.preventDefault();
    }, { passive: false });

    canvas.addEventListener('pointerup', (e) => {
      if (!isDrawing || !isPenActive) return;
      isDrawing = false;
      penStrokes.push(currentStroke);
      currentStroke = [];
      updateUndoResetState();
      e.preventDefault();
    }, { passive: false });

    canvas.addEventListener('pointerleave', () => {
      if (isDrawing && isPenActive) {
        isDrawing = false;
        penStrokes.push(currentStroke);
        currentStroke = [];
        updateUndoResetState();
      }
    });

    penToolBtn.addEventListener('click', () => {
      isPenActive = !isPenActive;
      penToolBtn.textContent = isPenActive ? `Pen (${brushSize}px)` : 'Pen';
      if (!isPenActive) isDrawing = false;
    });

    // ===== Brush Size Controls =====
    penPlusBtn.addEventListener('click', () => {
      brushSize = Math.min(100, brushSize + 5);
      penToolBtn.textContent = isPenActive ? `Pen (${brushSize}px)` : 'Pen';
    });
    penMinusBtn.addEventListener('click', () => {
      brushSize = Math.max(5, brushSize - 5);
      penToolBtn.textContent = isPenActive ? `Pen (${brushSize}px)` : 'Pen';
    });

    // ===== Undo & Reset =====
    undoBtn.addEventListener('click', () => {
      if (penStrokes.length === 0) return;
      penStrokes.pop();
      redrawBase();
      redrawPenStrokes();
    });
    resetBtn.addEventListener('click', () => {
      clearCanvas();
    });
    function updateUndoResetState() {
      undoBtn.disabled  = penStrokes.length === 0;
      resetBtn.disabled = penStrokes.length === 0;
    }
    function disableUndoReset() {
      undoBtn.disabled  = true;
      resetBtn.disabled = true;
    }
    function enableActionButtons() {
      saveBtn.disabled    = false;
      penToolBtn.disabled = false;
      penPlusBtn.disabled = false;
      penMinusBtn.disabled = false;
      updateUndoResetState();
    }
    function disableActionButtons() {
      saveBtn.disabled    = true;
      penToolBtn.disabled = true;
      penPlusBtn.disabled = true;
      penMinusBtn.disabled = true;
      undoBtn.disabled    = true;
      resetBtn.disabled   = true;
    }

    // ===== Save Redacted File =====
    saveBtn.addEventListener('click', async () => {
      if (currentMode === 'image' || currentMode === 'camera') {
        const link = document.createElement('a');
        link.href = canvas.toDataURL('image/png');
        link.download = 'redacted.png';
        link.click();
      } else if (currentMode === 'pdf') {
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({
          orientation: canvas.width > canvas.height ? 'l' : 'p',
          unit: 'pt',
          format: [canvas.width, canvas.height]
        });
        const imgData = canvas.toDataURL('image/png');
        pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);
        pdf.save('redacted.pdf');
      }
    });

    // ===== Initialization =====
    window.addEventListener('load', () => {
      clearCanvas();
      disableActionButtons();
    });
  </script>
</body>
</html>
