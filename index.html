<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Redact Tool</title>
  <!-- PDF.js for PDF rendering -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.6.172/pdf.min.js"></script>
  <!-- jsPDF for exporting PDF -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <style>
    /* ===== Global Reset & Body ===== */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    html, body {
      width: 100%;
      height: 100%;
      background: #0d0d0f;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: #fff;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* ===== Fullscreen Glassmorphic Container ===== */
    .glass-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      background: rgba(255, 255, 255, 0.03);
      backdrop-filter: blur(40px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .header {
      padding: 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(255, 255, 255, 0.05);
    }
    .header h1 {
      font-size: 1.8rem;
      font-weight: 600;
      color: #e0e0e0;
      text-shadow: 0 0 6px rgba(255, 255, 255, 0.3);
    }
    .header button {
      padding: 8px 14px;
      border: none;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.15);
      color: #fff;
      cursor: pointer;
      font-size: 0.95rem;
      transition: background 0.2s ease, transform 0.2s ease;
    }
    .header button:hover {
      background: rgba(255, 255, 255, 0.25);
      transform: translateY(-2px);
    }

    /* ===== Controls Row ===== */
    .controls {
      padding: 16px;
      display: flex;
      gap: 14px;
      justify-content: center;
      background: rgba(255, 255, 255, 0.04);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      flex-wrap: wrap;
    }
    .controls button {
      padding: 10px 18px;
      border: none;
      border-radius: 8px;
      background: linear-gradient(145deg, rgba(255,255,255,0.1), rgba(255,255,255,0));
      color: #fff;
      cursor: pointer;
      font-size: 1rem;
      transition: background 0.2s ease, transform 0.2s ease;
    }
    .controls button:hover {
      background: linear-gradient(145deg, rgba(255,255,255,0.2), rgba(255,255,255,0.05));
      transform: translateY(-2px);
    }

    /* ===== Main Canvas Area ===== */
    .canvas-area {
      flex: 1;
      position: relative;
      background: #1a1a1c;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    canvas, video {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      border-radius: 4px;
      display: block;
    }

    /* ===== Overlay Controls (Camera) ===== */
    .overlay-controls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 10;
    }
    .overlay-controls button {
      padding: 8px 14px;
      border: none;
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.12);
      color: #fff;
      cursor: pointer;
      font-size: 0.9rem;
      transition: background 0.2s ease, transform 0.2s ease;
    }
    .overlay-controls button:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: translateY(-1px);
    }

    /* ===== Hidden File Input ===== */
    #fileInput {
      display: none;
    }

    /* ===== Modal Styles ===== */
    .modal-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }
    .modal-content {
      width: 90%;
      max-width: 600px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 14px;
      backdrop-filter: blur(30px);
      border: 1px solid rgba(255, 255, 255, 0.15);
      padding: 28px;
      color: #fff;
      position: relative;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
    }
    .modal-content h2 {
      margin-bottom: 14px;
      font-size: 1.5rem;
      text-shadow: 0 0 6px rgba(255, 255, 255, 0.3);
    }
    .modal-content p {
      margin-bottom: 10px;
      line-height: 1.5;
      font-size: 1rem;
      color: #d0d0d0;
    }
    .modal-close {
      position: absolute;
      top: 14px;
      right: 14px;
      background: rgba(255, 255, 255, 0.1);
      border: none;
      border-radius: 6px;
      color: #fff;
      font-size: 1.1rem;
      padding: 6px 10px;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease;
    }
    .modal-close:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: translateY(-2px);
    }
  </style>
</head>
<body>
  <div class="glass-container">
    <div class="header">
      <h1>Redact & Save</h1>
      <button id="privacyBtn">Privacy Policy</button>
    </div>
    <div class="controls">
      <button id="openCameraBtn">Open Camera</button>
      <button id="uploadBtn">Upload File</button>
      <button id="penToolBtn" disabled>Pen Tool</button>
      <button id="undoBtn" disabled>Undo</button>
      <button id="resetBtn" disabled>Reset</button>
      <button id="saveBtn" disabled>Save Redacted</button>
      <input type="file" id="fileInput" accept="image/*,application/pdf" />
    </div>
    <div class="canvas-area" id="canvasArea">
      <video id="video" autoplay muted playsinline style="display:none; border-radius:4px;"></video>
      <canvas id="canvas"></canvas>
      <div class="overlay-controls" id="overlayControls" style="display:none;">
        <button id="captureBtn">Capture</button>
        <button id="stopCameraBtn">Close Camera</button>
      </div>
    </div>
  </div>

  <!-- Privacy Policy Modal -->
  <div class="modal-backdrop" id="modalBackdrop">
    <div class="modal-content">
      <button class="modal-close" id="modalCloseBtn">&times;</button>
      <h2>Privacy Policy</h2>
      <p>This redaction tool processes your images and PDF files entirely within your browser. No data, images, or files are ever uploaded to any external server or stored by this application.</p>
      <p>All redaction actions occur locally on your device. Once you click "Save Redacted," the output file (image or PDF) is generated and downloaded to your device only.</p>
      <p>We do not collect, retain, or share any user data. All intermediate data is discarded when you close the page or navigate away. By using this tool, you acknowledge that your data remains private and is not retained by the service.</p>
    </div>
  </div>

  <script>
    // ===== Global Variables =====
    const openCameraBtn = document.getElementById('openCameraBtn');
    const uploadBtn = document.getElementById('uploadBtn');
    const penToolBtn = document.getElementById('penToolBtn');
    const undoBtn = document.getElementById('undoBtn');
    const resetBtn = document.getElementById('resetBtn');
    const saveBtn = document.getElementById('saveBtn');
    const fileInput = document.getElementById('fileInput');
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const overlayControls = document.getElementById('overlayControls');
    const captureBtn = document.getElementById('captureBtn');
    const stopCameraBtn = document.getElementById('stopCameraBtn');
    const privacyBtn = document.getElementById('privacyBtn');
    const modalBackdrop = document.getElementById('modalBackdrop');
    const modalCloseBtn = document.getElementById('modalCloseBtn');

    let stream = null;
    let currentMode = null; // "camera" | "image" | "pdf"
    let isPenActive = false;
    let isDrawing = false;
    let pdfDoc = null;
    let pdfPageNum = 1;
    let loadedImage = new Image();

    // Pen strokes: array of paths (each path is array of points)
    let penStrokes = [];
    let currentStroke = [];

    // ===== Utility: Resize canvas & redraw existing content =====
    function resizeCanvas() {
      const rect = canvas.parentElement.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;
      if (currentMode === 'image' && loadedImage.src) {
        drawImageOnCanvas(loadedImage);
      } else if (currentMode === 'pdf' && pdfDoc) {
        renderPdfPage(pdfPageNum);
      }
    }
    window.addEventListener('resize', resizeCanvas);

    // ===== Camera Handlers =====
    openCameraBtn.addEventListener('click', async () => {
      if (stream) return;
      try {
        stream = await navigator.mediaDevices.getUserMedia({ video: true });
        video.srcObject = stream;
        video.style.display = 'block';
        overlayControls.style.display = 'flex';
        currentMode = 'camera';
        resizeCanvas();
        disableActionButtons();
      } catch (err) {
        alert('Unable to access camera: ' + err.message);
      }
    });
    captureBtn.addEventListener('click', () => {
      if (!stream) return;
      const rect = canvas.getBoundingClientRect();
      ctx.drawImage(video, 0, 0, rect.width, rect.height);
      stopCamera();
      currentMode = 'image';
      loadedImage.src = canvas.toDataURL('image/png');
      loadedImage.onload = () => {
        drawImageOnCanvas(loadedImage);
        enableActionButtons();
      };
    });
    stopCameraBtn.addEventListener('click', stopCamera);
    function stopCamera() {
      if (stream) {
        stream.getTracks().forEach((t) => t.stop());
        stream = null;
        video.style.display = 'none';
        overlayControls.style.display = 'none';
      }
    }

    // ===== Upload Handlers =====
    uploadBtn.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      console.log('Selected file:', file);
      const fileType = file.type;
      clearCanvas();
      if (fileType === 'application/pdf') {
        currentMode = 'pdf';
        const arrayBuffer = await file.arrayBuffer();
        await loadAndRenderPdf(arrayBuffer);
      } else if (fileType.startsWith('image/')) {
        currentMode = 'image';
        const url = URL.createObjectURL(file);
        loadedImage = new Image();
        loadedImage.src = url;
        loadedImage.onload = () => {
          drawImageOnCanvas(loadedImage);
          enableActionButtons();
        };
      } else {
        alert('Unsupported file type. Please upload a PDF or image.');
      }
      fileInput.value = '';
    });

    // ===== PDF Rendering with PDF.js =====
    async function loadAndRenderPdf(data) {
      try {
        pdfDoc = await pdfjsLib.getDocument({ data }).promise;
        pdfPageNum = 1;
        renderPdfPage(pdfPageNum);
      } catch (err) {
        console.error('PDF load error:', err);
        alert('Failed to load PDF.');
      }
    }
    function renderPdfPage(num) {
      pdfDoc.getPage(num).then((page) => {
        const rect = canvas.parentElement.getBoundingClientRect();
        const vpOrig = page.getViewport({ scale: 1 });
        const ratio = Math.min(rect.width / vpOrig.width, rect.height / vpOrig.height);
        const viewport = page.getViewport({ scale: ratio });
        canvas.width = viewport.width;
        canvas.height = viewport.height;

        const renderContext = {
          canvasContext: ctx,
          viewport: viewport
        };
        page.render(renderContext).promise.then(() => {
          redrawPenStrokes();
          enableActionButtons();
        }).catch((err) => {
          console.error('PDF render promise error:', err);
        });
      }).catch((err) => {
        console.error('PDF render error:', err);
      });
    }

    // ===== Drawing & Pen Redaction =====
    function clearCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      penStrokes = [];
      currentStroke = [];
      redrawBase();
      disableUndoReset();
    }
    function drawImageOnCanvas(img) {
      const rect = canvas.parentElement.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;
      ctx.drawImage(img, 0, 0, rect.width, rect.height);
      redrawPenStrokes();
      enableActionButtons();
    }
    function redrawBase() {
      if (currentMode === 'image' && loadedImage.src) {
        const rect = canvas.parentElement.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;
        ctx.drawImage(loadedImage, 0, 0, rect.width, rect.height);
      } else if (currentMode === 'pdf' && pdfDoc) {
        renderPdfPage(pdfPageNum);
      }
    }
    function redrawPenStrokes() {
      penStrokes.forEach((stroke) => {
        ctx.save();
        ctx.globalCompositeOperation = 'source-over';
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 30;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath();
        stroke.forEach((pt, idx) => {
          if (idx === 0) ctx.moveTo(pt.x, pt.y);
          else ctx.lineTo(pt.x, pt.y);
        });
        ctx.stroke();
        ctx.restore();
      });
      updateUndoResetState();
    }

    canvas.addEventListener('mousedown', (e) => {
      if (!['image', 'pdf'].includes(currentMode) || !isPenActive) return;
      isDrawing = true;
      currentStroke = [];
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      currentStroke.push({ x, y });
    });
    canvas.addEventListener('mousemove', (e) => {
      if (!isDrawing || !isPenActive) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      currentStroke.push({ x, y });
      ctx.save();
      ctx.globalCompositeOperation = 'source-over';
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 30;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.beginPath();
      const lastIdx = currentStroke.length - 1;
      if (lastIdx > 0) {
        const prevPt = currentStroke[lastIdx - 1];
        ctx.moveTo(prevPt.x, prevPt.y);
        ctx.lineTo(currentStroke[lastIdx].x, currentStroke[lastIdx].y);
        ctx.stroke();
      }
      ctx.restore();
    });
    canvas.addEventListener('mouseup', () => {
      if (!isDrawing || !isPenActive) return;
      isDrawing = false;
      penStrokes.push(currentStroke);
      currentStroke = [];
      updateUndoResetState();
    });
    canvas.addEventListener('mouseleave', () => {
      if (isDrawing && isPenActive) {
        isDrawing = false;
        penStrokes.push(currentStroke);
        currentStroke = [];
        updateUndoResetState();
      }
    });

    penToolBtn.addEventListener('click', () => {
      isPenActive = !isPenActive;
      penToolBtn.textContent = isPenActive ? 'Pen Active (Click to Disable)' : 'Pen Tool';
      penToolBtn.style.background = isPenActive 
        ? 'linear-gradient(145deg, rgba(200,0,0,0.4), rgba(200,0,0,0.2))'
        : 'linear-gradient(145deg, rgba(255,255,255,0.1), rgba(255,255,255,0))';
      if (!isPenActive) {
        isDrawing = false;
      }
    });

    // ===== Undo & Reset =====
    undoBtn.addEventListener('click', () => {
      if (penStrokes.length === 0) return;
      penStrokes.pop();
      redrawBase();
      redrawPenStrokes();
    });
    resetBtn.addEventListener('click', () => {
      clearCanvas();
    });
    function updateUndoResetState() {
      undoBtn.disabled = penStrokes.length === 0;
      resetBtn.disabled = penStrokes.length === 0;
    }
    function disableUndoReset() {
      undoBtn.disabled = true;
      resetBtn.disabled = true;
    }
    function enableActionButtons() {
      saveBtn.disabled = false;
      penToolBtn.disabled = false;
      updateUndoResetState();
    }
    function disableActionButtons() {
      saveBtn.disabled = true;
      penToolBtn.disabled = true;
      undoBtn.disabled = true;
      resetBtn.disabled = true;
    }

    // ===== Save Redacted File =====
    saveBtn.addEventListener('click', async () => {
      if (currentMode === 'image' || currentMode === 'camera') {
        const link = document.createElement('a');
        link.href = canvas.toDataURL('image/png');
        link.download = 'redacted.png';
        link.click();
      } else if (currentMode === 'pdf') {
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({
          orientation: canvas.width > canvas.height ? 'l' : 'p',
          unit: 'pt',
          format: [canvas.width, canvas.height]
        });
        const imgData = canvas.toDataURL('image/png');
        pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);
        pdf.save('redacted.pdf');
      }
    });

    // ===== Privacy Modal Handlers =====
    privacyBtn.addEventListener('click', () => {
      modalBackdrop.style.display = 'flex';
    });
    modalCloseBtn.addEventListener('click', () => {
      modalBackdrop.style.display = 'none';
    });
    modalBackdrop.addEventListener('click', (e) => {
      if (e.target === modalBackdrop) {
        modalBackdrop.style.display = 'none';
      }
    });

    // ===== Initialization =====
    window.addEventListener('load', () => {
      resizeCanvas();
      disableActionButtons();
    });
  </script>
</body>
</html>
