<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <!-- Responsive scaling and safe‐area for notches -->
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Redact & Save Tool</title>

  <!-- PDF.js for PDF rendering -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.6.172/pdf.min.js"></script>
  <!-- jsPDF for exporting PDF -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <style>
    /* ===== Global Reset ===== */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    html, body {
      width: 100%;
      height: 100%;
      background: #0d0d0f;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      overscroll-behavior: none; /* prevent pull‐to‐refresh */
    }

    /* ===== Glassmorphic Container ===== */
    .glass-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      background: rgba(255, 255, 255, 0.03);
      backdrop-filter: blur(40px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* ===== Header (Safe‐area support) ===== */
    .header {
      padding-top: env(safe-area-inset-top, 16px);
      padding-bottom: 12px;
      padding-left: 20px;
      padding-right: 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(255, 255, 255, 0.05);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    .header h1 {
      font-size: clamp(1.5rem, 5vw, 2rem);
      font-weight: 600;
      color: #e0e0e0;
      text-shadow: 0 0 6px rgba(255, 255, 255, 0.3);
    }
    .header button {
      padding: 6px 12px;
      border: none;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.15);
      color: #fff;
      cursor: pointer;
      font-size: 0.9rem;
      transition: background 0.2s ease, transform 0.2s ease;
    }
    .header button:hover {
      background: rgba(255, 255, 255, 0.25);
      transform: translateY(-2px);
    }

    /* ===== Controls Row ===== */
    .controls {
      padding: 12px 16px;
      display: flex;
      gap: 10px;
      justify-content: center;
      background: rgba(255, 255, 255, 0.04);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      flex-wrap: wrap;
    }
    .controls button {
      padding: 8px 12px;
      border: none;
      border-radius: 8px;
      background: linear-gradient(145deg, rgba(255,255,255,0.1), rgba(255,255,255,0));
      color: #fff;
      cursor: pointer;
      font-size: 0.95rem;
      transition: background 0.2s ease, transform 0.2s ease;
    }
    .controls button:hover {
      background: linear-gradient(145deg, rgba(255,255,255,0.2), rgba(255,255,255,0.05));
      transform: translateY(-2px);
    }

    /* ===== Main Canvas Area ===== */
    .canvas-area {
      flex: 1;
      position: relative;
      background: #1a1a1c;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      touch-action: none; /* prevent default gestures */
    }
    video {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 4px;
      z-index: 1;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      border-radius: 4px;
      z-index: 2;
      pointer-events: auto;
      touch-action: none;
    }

    /* ===== Overlay Controls (Camera) ===== */
    .overlay-controls {
      position: absolute;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
      z-index: 3;
    }
    .overlay-controls button {
      padding: 6px 10px;
      border: none;
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.12);
      color: #fff;
      cursor: pointer;
      font-size: 0.85rem;
      transition: background 0.2s ease, transform 0.2s ease;
    }
    .overlay-controls button:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: translateY(-1px);
    }

    /* ===== Hidden File Input ===== */
    #fileInput {
      display: none;
    }

    /* ===== Modal Styles ===== */
    .modal-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }
    .modal-content {
      width: 90%;
      max-width: 600px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 14px;
      backdrop-filter: blur(30px);
      border: 1px solid rgba(255, 255, 255, 0.15);
      padding: 24px;
      color: #fff;
      position: relative;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
    }
    .modal-content h2 {
      margin-bottom: 10px;
      font-size: 1.3rem;
      text-shadow: 0 0 6px rgba(255, 255, 255, 0.3);
    }
    .modal-content p {
      margin-bottom: 8px;
      line-height: 1.5;
      font-size: 0.95rem;
      color: #d0d0d0;
    }
    .modal-close {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.1);
      border: none;
      border-radius: 6px;
      color: #fff;
      font-size: 1rem;
      padding: 4px 8px;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease;
    }
    .modal-close:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: translateY(-2px);
    }
  </style>
</head>
<body>
  <div class="glass-container">
    <div class="header">
      <h1>Redact & Save</h1>
      <button id="privacyBtn">Privacy Policy</button>
    </div>

    <div class="controls">
      <button id="openCameraBtn">Open Camera</button>
      <button id="uploadBtn">Upload File</button>
      <button id="penToolBtn" disabled>Pen Tool</button>
      <button id="undoBtn" disabled>Undo</button>
      <button id="resetBtn" disabled>Reset</button>
      <button id="saveBtn" disabled>Save Redacted</button>
      <input type="file" id="fileInput" accept="image/*,application/pdf" capture="environment" />
    </div>

    <div class="canvas-area" id="canvasArea">
      <video id="video" autoplay muted playsinline style="display:none;"></video>
      <canvas id="canvas"></canvas>
      <div class="overlay-controls" id="overlayControls" style="display:none;">
        <button id="captureBtn">Capture</button>
        <button id="stopCameraBtn">Close Camera</button>
      </div>
    </div>
  </div>

  <!-- Privacy Policy Modal -->
  <div class="modal-backdrop" id="modalBackdrop">
    <div class="modal-content">
      <button class="modal-close" id="modalCloseBtn">&times;</button>
      <h2>Privacy Policy</h2>
      <p>This redaction tool processes your images and PDF files entirely within your browser. No data, images, or files are ever uploaded to any external server or stored by this application.</p>
      <p>All redaction actions occur locally on your device. Once you click "Save Redacted," the output file (image or PDF) is generated and downloaded to your device only.</p>
      <p>We do not collect, retain, or share any user data. All intermediate data is discarded when you close the page or navigate away. By using this tool, you acknowledge that your data remains private and is not retained by the service.</p>
    </div>
  </div>

  <script>
    // ===== Global Variables =====
    const openCameraBtn = document.getElementById('openCameraBtn');
    const uploadBtn = document.getElementById('uploadBtn');
    const penToolBtn = document.getElementById('penToolBtn');
    const undoBtn = document.getElementById('undoBtn');
    const resetBtn = document.getElementById('resetBtn');
    const saveBtn = document.getElementById('saveBtn');
    const fileInput = document.getElementById('fileInput');
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const overlayControls = document.getElementById('overlayControls');
    const captureBtn = document.getElementById('captureBtn');
    const stopCameraBtn = document.getElementById('stopCameraBtn');
    const privacyBtn = document.getElementById('privacyBtn');
    const modalBackdrop = document.getElementById('modalBackdrop');
    const modalCloseBtn = document.getElementById('modalCloseBtn');

    let stream = null;
    let currentMode = null; // "camera" | "image" | "pdf"
    let isPenActive = false;
    let isDrawing = false;
    let pdfDoc = null;
    let pdfPageNum = 1;
    let loadedImage = new Image();

    // Pen strokes: array of paths (each path is array of points)
    let penStrokes = [];
    let currentStroke = [];

    // ===== Utility: Resize Canvas =====
    function resizeCanvas() {
      const rect = canvas.parentElement.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;
      if (currentMode === 'image' && loadedImage.src) {
        drawImageOnCanvas(loadedImage);
      } else if (currentMode === 'pdf' && pdfDoc) {
        renderPdfPage(pdfPageNum);
      }
    }
    window.addEventListener('resize', resizeCanvas);

    // ===== Camera Handlers =====
    openCameraBtn.addEventListener('click', async () => {
      if (stream) return;
      try {
        // Try exact rear camera first
        stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: { exact: 'environment' } }
        });
      } catch (err) {
        // Fallback to rear camera if exact fails
        try {
          stream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: 'environment' }
          });
        } catch {
          stream = null;
        }
      }

      if (stream) {
        video.srcObject = stream;
        video.style.display = 'block';
        overlayControls.style.display = 'flex';
        currentMode = 'camera';
        resizeCanvas();
        disableActionButtons();
      } else {
        alert(
          'Unable to access the rear camera.\n' +
          '• Ensure you’re on HTTPS (not file:// or HTTP).\n' +
          '• If in an iframe, include allow="camera" on the iframe.\n' +
          '• Close any overlays (chat bubbles, etc.) blocking the permission prompt.'
        );
      }
    });

    captureBtn.addEventListener('click', () => {
      if (!stream) return;
      const rect = canvas.getBoundingClientRect();
      ctx.drawImage(video, 0, 0, rect.width, rect.height);

      // Stop & hide video immediately
      stopCamera();
      video.style.display = 'none';
      video.srcObject = null;

      currentMode = 'image';
      loadedImage.src = canvas.toDataURL('image/png');
      loadedImage.onload = () => {
        drawImageOnCanvas(loadedImage);
        enableActionButtons();
      };
    });

    stopCameraBtn.addEventListener('click', stopCamera);
    function stopCamera() {
      if (stream) {
        stream.getTracks().forEach((t) => t.stop());
        stream = null;
        video.style.display = 'none';
        overlayControls.style.display = 'none';
      }
    }

    // ===== Upload Handlers =====
    uploadBtn.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const fileType = file.type;
      clearCanvas();
      if (fileType === 'application/pdf') {
        currentMode = 'pdf';
        const arrayBuffer = await file.arrayBuffer();
        await loadAndRenderPdf(arrayBuffer);
      } else if (fileType.startsWith('image/')) {
        currentMode = 'image';
        const url = URL.createObjectURL(file);
        loadedImage = new Image();
        loadedImage.src = url;
        loadedImage.onload = () => {
          drawImageOnCanvas(loadedImage);
          enableActionButtons();
        };
      } else {
        alert('Unsupported file type. Please upload a PDF or image.');
      }
      fileInput.value = '';
    });

    // ===== PDF Rendering with PDF.js =====
    async function loadAndRenderPdf(data) {
      try {
        pdfDoc = await pdfjsLib.getDocument({ data }).promise;
        pdfPageNum = 1;
        renderPdfPage(pdfPageNum);
      } catch (err) {
        console.error('PDF load error:', err);
        alert('Failed to load PDF.');
      }
    }
    function renderPdfPage(num) {
      pdfDoc.getPage(num).then((page) => {
        const rect = canvas.parentElement.getBoundingClientRect();
        const vpOrig = page.getViewport({ scale: 1 });
        const ratio = Math.min(rect.width / vpOrig.width, rect.height / vpOrig.height);
        const viewport = page.getViewport({ scale: ratio });
        canvas.width = viewport.width;
        canvas.height = viewport.height;

        const renderContext = {
          canvasContext: ctx,
          viewport: viewport
        };
        page.render(renderContext).promise.then(() => {
          redrawPenStrokes();
          enableActionButtons();
        }).catch((err) => {
          console.error('PDF render promise error:', err);
        });
      }).catch((err) => {
        console.error('PDF render error:', err);
      });
    }

    // ===== Drawing & Pen Redaction (Pointer Events) =====
    function clearCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      penStrokes = [];
      currentStroke = [];
      redrawBase();
      disableUndoReset();
    }
    function drawImageOnCanvas(img) {
      const rect = canvas.parentElement.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;
      ctx.drawImage(img, 0, 0, rect.width, rect.height);
      redrawPenStrokes();
      enableActionButtons();
    }
    function redrawBase() {
      if (currentMode === 'image' && loadedImage.src) {
        const rect = canvas.parentElement.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;
        ctx.drawImage(loadedImage, 0, 0, rect.width, rect.height);
      } else if (currentMode === 'pdf' && pdfDoc) {
        renderPdfPage(pdfPageNum);
      }
    }
    function redrawPenStrokes() {
      penStrokes.forEach((stroke) => {
        ctx.save();
        ctx.globalCompositeOperation = 'source-over';
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 30;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath();
        stroke.forEach((pt, idx) => {
          if (idx === 0) ctx.moveTo(pt.x, pt.y);
          else ctx.lineTo(pt.x, pt.y);
        });
        ctx.stroke();
        ctx.restore();
      });
      updateUndoResetState();
    }

    // Pointer event handlers for drawing
    canvas.addEventListener('pointerdown', (e) => {
      if (!['image','pdf'].includes(currentMode) || !isPenActive) return;
      isDrawing = true;
      currentStroke = [];
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      currentStroke.push({ x, y });
      e.preventDefault();
    }, { passive: false });

    canvas.addEventListener('pointermove', (e) => {
      if (!isDrawing || !isPenActive) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      currentStroke.push({ x, y });

      ctx.save();
      ctx.globalCompositeOperation = 'source-over';
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 30;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.beginPath();
      const lastIdx = currentStroke.length - 1;
      if (lastIdx > 0) {
        const prevPt = currentStroke[lastIdx - 1];
        ctx.moveTo(prevPt.x, prevPt.y);
        ctx.lineTo(currentStroke[lastIdx].x, currentStroke[lastIdx].y);
        ctx.stroke();
      }
      ctx.restore();

      e.preventDefault();
    }, { passive: false });

    canvas.addEventListener('pointerup', (e) => {
      if (!isDrawing || !isPenActive) return;
      isDrawing = false;
      penStrokes.push(currentStroke);
      currentStroke = [];
      updateUndoResetState();
      e.preventDefault();
    }, { passive: false });

    canvas.addEventListener('pointerleave', () => {
      if (isDrawing && isPenActive) {
        isDrawing = false;
        penStrokes.push(currentStroke);
        currentStroke = [];
        updateUndoResetState();
      }
    });

    penToolBtn.addEventListener('click', () => {
      isPenActive = !isPenActive;
      penToolBtn.textContent = isPenActive ? 'Pen Active (Click to Disable)' : 'Pen Tool';
      if (!isPenActive) {
        isDrawing = false;
      }
    });

    // ===== Undo & Reset =====
    undoBtn.addEventListener('click', () => {
      if (penStrokes.length === 0) return;
      penStrokes.pop();
      redrawBase();
      redrawPenStrokes();
    });
    resetBtn.addEventListener('click', () => {
      clearCanvas();
    });
    function updateUndoResetState() {
      undoBtn.disabled = penStrokes.length === 0;
      resetBtn.disabled = penStrokes.length === 0;
    }
    function disableUndoReset() {
      undoBtn.disabled = true;
      resetBtn.disabled = true;
    }
    function enableActionButtons() {
      saveBtn.disabled = false;
      penToolBtn.disabled = false;
      updateUndoResetState();
    }
    function disableActionButtons() {
      saveBtn.disabled = true;
      penToolBtn.disabled = true;
      undoBtn.disabled = true;
      resetBtn.disabled = true;
    }

    // ===== Save Redacted File =====
    saveBtn.addEventListener('click', async () => {
      if (currentMode === 'image' || currentMode === 'camera') {
        const link = document.createElement('a');
        link.href = canvas.toDataURL('image/png');
        link.download = 'redacted.png';
        link.click();
      } else if (currentMode === 'pdf') {
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({
          orientation: canvas.width > canvas.height ? 'l' : 'p',
          unit: 'pt',
          format: [canvas.width, canvas.height]
        });
        const imgData = canvas.toDataURL('image/png');
        pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);
        pdf.save('redacted.pdf');
      }
    });

    // ===== Privacy Modal Handlers =====
    privacyBtn.addEventListener('click', () => {
      modalBackdrop.style.display = 'flex';
    });
    modalCloseBtn.addEventListener('click', () => {
      modalBackdrop.style.display = 'none';
    });
    modalBackdrop.addEventListener('click', (e) => {
      if (e.target === modalBackdrop) {
        modalBackdrop.style.display = 'none';
      }
    });

    // ===== Initialization =====
    window.addEventListener('load', () => {
      resizeCanvas();
      disableActionButtons();
    });
  </script>
</body>
</html>
